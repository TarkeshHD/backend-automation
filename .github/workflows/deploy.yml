name: AWS Infrastructure Setup

on:
  workflow_dispatch:
    inputs:
      client_name:
        description: 'Client Name (used for key pair)'
        required: true
        type: string
      instance_type:
        description: 'EC2 Instance Type'
        required: true
        default: 't3.micro'
        type: choice
        options:
          - t3.micro
          - t3.small
          - t3.medium
          - t3.large
      instance_name:
        description: 'EC2 Instance Name Tag'
        required: true
        default: 'CodeDeploy-Instance'
        type: string
      domain_name:
        description: 'Domain name pointing to Elastic IP'
        required: true
        type: string
      email:
        description: 'Email for SSL certificate registration'
        required: true
        type: string

env:
  AWS_REGION: us-east-1
  EC2_ROLE_NAME: EC2-CodeDeploy-Role
  SECURITY_GROUP_NAME: CodeDeploy-Security-Group

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create EC2 IAM Role and Instance Profile
        run: |
          cat > ec2-trust-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": { "Service": "ec2.amazonaws.com" },
                "Action": "sts:AssumeRole"
              }
            ]
          }
          EOF
          if ! aws iam get-role --role-name ${{ env.EC2_ROLE_NAME }} >/dev/null 2>&1; then
            aws iam create-role \
              --role-name ${{ env.EC2_ROLE_NAME }} \
              --assume-role-policy-document file://ec2-trust-policy.json
            aws iam attach-role-policy --role-name ${{ env.EC2_ROLE_NAME }} --policy-arn arn:aws:iam::aws:policy/AmazonEC2FullAccess
            aws iam attach-role-policy --role-name ${{ env.EC2_ROLE_NAME }} --policy-arn arn:aws:iam::aws:policy/service-role/AWSCodeDeployRole
          fi
          if ! aws iam get-instance-profile --instance-profile-name ${{ env.EC2_ROLE_NAME }} >/dev/null 2>&1; then
            aws iam create-instance-profile --instance-profile-name ${{ env.EC2_ROLE_NAME }}
          fi
          ATTACHED_ROLE=$(aws iam get-instance-profile --instance-profile-name ${{ env.EC2_ROLE_NAME }} --query 'InstanceProfile.Roles[0].RoleName' --output text 2>/dev/null || echo "None")
          if [ "$ATTACHED_ROLE" != "${{ env.EC2_ROLE_NAME }}" ]; then
            aws iam add-role-to-instance-profile --instance-profile-name ${{ env.EC2_ROLE_NAME }} --role-name ${{ env.EC2_ROLE_NAME }}
          fi

      - name: Create Security Group
        id: create-sg
        run: |
          if [ "$EXISTING_SG" != "" ] && [ "$EXISTING_SG" != "None" ]; then
            echo "Security group already exists: $EXISTING_SG"
            echo "SECURITY_GROUP_ID=$EXISTING_SG" >> $GITHUB_OUTPUT
          else
            SG_ID=$(aws ec2 create-security-group \
              --group-name ${{ env.SECURITY_GROUP_NAME }} \
              --description "SG for CodeDeploy" \
              --vpc-id $VPC_ID \
              --query 'GroupId' --output text)
            for PORT in 22 80 443 27017; do
              aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port $PORT --cidr 0.0.0.0/0
            done
            echo "SECURITY_GROUP_ID=$SG_ID" >> $GITHUB_OUTPUT
          fi


      - name: Create Key Pair
        id: create-key
        run: |
          KEY_NAME=${{ github.event.inputs.client_name }}-key-${{ github.run_id }}
          aws ec2 create-key-pair --key-name "$KEY_NAME" --query 'KeyMaterial' --output text > "$KEY_NAME.pem"
          chmod 400 "$KEY_NAME.pem"
          echo "KEY_NAME=$KEY_NAME" >> $GITHUB_ENV

      - name: Upload Key Pair Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ec2-private-key
          path: ${{ env.KEY_NAME }}.pem

      - name: Get Latest Ubuntu AMI
        id: get-ami
        run: |
          AMI_ID=$(aws ec2 describe-images --owners 099720109477 --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*" --query 'Images|sort_by(@, &CreationDate)[-1].ImageId' --output text)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV

      - name: Create EC2 Instance with NGINX + Certbot + App Setup
        run: |
          cat <<EOF > user-data.sh
          #!/bin/bash
          apt update -y
          apt install -y nginx nodejs npm mongodb curl software-properties-common

          systemctl enable nginx
          systemctl start nginx

          systemctl enable mongod
          systemctl start mongod

          add-apt-repository -y ppa:certbot/certbot
          apt update -y
          apt install -y certbot python3-certbot-nginx

          certbot --nginx --non-interactive --agree-tos --email ${{ github.event.inputs.email }} -d ${{ github.event.inputs.domain_name }}

          cd /home/ubuntu
          git clone https://github.com/${{ secrets.GH_USERNAME }}/your-repo-name.git
          cd your-repo-name
          npm install
          npm install -g pm2
          pm2 start server.js --name "vrse-app"
          pm2 save
          pm2 startup systemd

          cat <<NGINX > /etc/nginx/sites-available/default
          server {
              listen 80;
              server_name ${{ github.event.inputs.domain_name }};
              return 301 https://\$host\$request_uri;
          }

          server {
              listen 443 ssl;
              server_name ${{ github.event.inputs.domain_name }};

              ssl_certificate /etc/letsencrypt/live/${{ github.event.inputs.domain_name }}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${{ github.event.inputs.domain_name }}/privkey.pem;

              location / {
                  proxy_pass http://localhost:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_cache_bypass \$http_upgrade;
              }
          }
          NGINX
          systemctl restart nginx
          EOF

          chmod +x user-data.sh

          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ${{ env.AMI_ID }} \
            --instance-type ${{ github.event.inputs.instance_type }} \
            --key-name ${{ env.KEY_NAME }} \
            --security-group-ids ${{ env.SG_ID }} \
            --iam-instance-profile Name=${{ env.EC2_ROLE_NAME }} \
            --user-data file://user-data.sh \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${{ github.event.inputs.instance_name }}]" \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "Launched instance: \$INSTANCE_ID"
          aws ec2 wait instance-running --instance-ids \$INSTANCE_ID
          echo "âœ… EC2 instance is now running."
