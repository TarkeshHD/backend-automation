name: Deploy Backend to EKS

on:
  workflow_dispatch:

jobs:
  deploy-backend:
    runs-on: ubuntu-latest

    env:
      BACKEND_NAME: backend
      BACKEND_DIR: vrse-builder-backend-main
      CLUSTER_NAME: Backend-cluster
      DOMAIN_NAME: poc-api.autovrse.app

    steps:
      - name: ğŸ“ Checkout repo
        uses: actions/checkout@v3

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ğŸ§° Install eksctl, kubectl, and Helm
        run: |
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin

          curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: ğŸ”„ Ensure EKS Cluster
        run: |
          if aws eks describe-cluster --name "$CLUSTER_NAME" --region "${{ secrets.AWS_REGION }}" >/dev/null 2>&1; then
            echo "âœ… EKS Cluster $CLUSTER_NAME exists."
          else
            echo "âŒ Cluster does not exist. Exiting."
            exit 1
          fi

      - name: ğŸ“¡ Update kubeconfig
        run: |
          aws eks update-kubeconfig --region "${{ secrets.AWS_REGION }}" --name "$CLUSTER_NAME"

      - name: ğŸ“¦ Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Build and push backend Docker image
        run: |
          IMAGE="${{ steps.login-ecr.outputs.registry }}/$BACKEND_NAME"
          TAG="${GITHUB_SHA::7}"

          docker build -t $IMAGE:$TAG -t $IMAGE:latest -f $BACKEND_DIR/Dockerfile $BACKEND_DIR
          docker push $IMAGE:$TAG
          docker push $IMAGE:latest

          echo "IMAGE=$IMAGE:$TAG" >> $GITHUB_ENV

      - name: ğŸ§¾ Replace image in deployment
        run: |
          sed -i "s|image:.*|image: $IMAGE|" $BACKEND_DIR/backend-deployment.yaml

      - name: ğŸš€ Apply K8s manifests (deployment + service)
        run: |
          kubectl apply -f $BACKEND_DIR/backend-deployment.yaml
          kubectl apply -f $BACKEND_DIR/backend-service.yaml

      - name: â˜ï¸ Deploy Ingress Controller (if not exists)
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace

      - name: ğŸ“¥ Wait for Ingress External IP
        id: wait-ip
        run: |
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [[ -z "$EXTERNAL_IP" ]]; then
              echo "Attempt $i: Waiting for external IP..."
              sleep 10
            else
              echo "âœ… External IP: $EXTERNAL_IP"
              echo "external_ip=$EXTERNAL_IP" >> $GITHUB_OUTPUT
              break
            fi
          done

      - name: ğŸ“Œ Show DNS setup info for Squarespace
        run: |
          echo "ğŸ”— Please add a CNAME record in Squarespace:"
          echo "Host: poc-api.autovrse.app"
          echo "Type: CNAME"
          echo "Value: ${{ steps.wait-ip.outputs.external_ip }}"

      - name: ğŸ” Install Cert Manager
        run: |
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml

      - name: ğŸ“œ Create ClusterIssuer
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: your-email@example.com
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF

      - name: ğŸ” Create TLS Certificate
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: backend-cert
            namespace: default
          spec:
            secretName: backend-tls
            issuerRef:
              name: letsencrypt-prod
              kind: ClusterIssuer
            commonName: $DOMAIN_NAME
            dnsNames:
              - $DOMAIN_NAME
          EOF

      - name: ğŸŒ Create Ingress
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: backend-ingress
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
          spec:
            tls:
              - hosts:
                  - $DOMAIN_NAME
                secretName: backend-tls
            rules:
              - host: $DOMAIN_NAME
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: backend-service
                          port:
                            number: 80
          EOF

      - name: âœ… Final Check
        run: |
          echo "âœ… Your backend should be accessible soon at https://$DOMAIN_NAME"
